/* automatically generated by rust-bindgen 0.55.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const TEEC_CONFIG_PAYLOAD_REF_COUNT: u32 = 4;
pub const TEEC_NONE: u32 = 0;
pub const TEEC_VALUE_INPUT: u32 = 1;
pub const TEEC_VALUE_OUTPUT: u32 = 2;
pub const TEEC_VALUE_INOUT: u32 = 3;
pub const TEEC_MEMREF_TEMP_INPUT: u32 = 5;
pub const TEEC_MEMREF_TEMP_OUTPUT: u32 = 6;
pub const TEEC_MEMREF_TEMP_INOUT: u32 = 7;
pub const TEEC_MEMREF_WHOLE: u32 = 12;
pub const TEEC_MEMREF_PARTIAL_INPUT: u32 = 13;
pub const TEEC_MEMREF_PARTIAL_OUTPUT: u32 = 14;
pub const TEEC_MEMREF_PARTIAL_INOUT: u32 = 15;
pub const TEEC_MEM_INPUT: u32 = 1;
pub const TEEC_MEM_OUTPUT: u32 = 2;
pub const TEEC_SUCCESS: u32 = 0;
pub const TEEC_ERROR_STORAGE_NOT_AVAILABLE: u32 = 4027580419;
pub const TEEC_ERROR_GENERIC: u32 = 4294901760;
pub const TEEC_ERROR_ACCESS_DENIED: u32 = 4294901761;
pub const TEEC_ERROR_CANCEL: u32 = 4294901762;
pub const TEEC_ERROR_ACCESS_CONFLICT: u32 = 4294901763;
pub const TEEC_ERROR_EXCESS_DATA: u32 = 4294901764;
pub const TEEC_ERROR_BAD_FORMAT: u32 = 4294901765;
pub const TEEC_ERROR_BAD_PARAMETERS: u32 = 4294901766;
pub const TEEC_ERROR_BAD_STATE: u32 = 4294901767;
pub const TEEC_ERROR_ITEM_NOT_FOUND: u32 = 4294901768;
pub const TEEC_ERROR_NOT_IMPLEMENTED: u32 = 4294901769;
pub const TEEC_ERROR_NOT_SUPPORTED: u32 = 4294901770;
pub const TEEC_ERROR_NO_DATA: u32 = 4294901771;
pub const TEEC_ERROR_OUT_OF_MEMORY: u32 = 4294901772;
pub const TEEC_ERROR_BUSY: u32 = 4294901773;
pub const TEEC_ERROR_COMMUNICATION: u32 = 4294901774;
pub const TEEC_ERROR_SECURITY: u32 = 4294901775;
pub const TEEC_ERROR_SHORT_BUFFER: u32 = 4294901776;
pub const TEEC_ERROR_EXTERNAL_CANCEL: u32 = 4294901777;
pub const TEEC_ERROR_TARGET_DEAD: u32 = 4294914084;
pub const TEEC_ORIGIN_API: u32 = 1;
pub const TEEC_ORIGIN_COMMS: u32 = 2;
pub const TEEC_ORIGIN_TEE: u32 = 3;
pub const TEEC_ORIGIN_TRUSTED_APP: u32 = 4;
pub const TEEC_LOGIN_PUBLIC: u32 = 0;
pub const TEEC_LOGIN_USER: u32 = 1;
pub const TEEC_LOGIN_GROUP: u32 = 2;
pub const TEEC_LOGIN_APPLICATION: u32 = 4;
pub const TEEC_LOGIN_USER_APPLICATION: u32 = 5;
pub const TEEC_LOGIN_GROUP_APPLICATION: u32 = 6;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type TEEC_Result = u32;
#[doc = " struct TEEC_Context - Represents a connection between a client application"]
#[doc = " and a TEE."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TEEC_Context {
    pub fd: ::std::os::raw::c_int,
    pub reg_mem: bool,
}
#[test]
fn bindgen_test_layout_TEEC_Context() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_Context>(),
        8usize,
        concat!("Size of: ", stringify!(TEEC_Context))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_Context>(),
        4usize,
        concat!("Alignment of ", stringify!(TEEC_Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Context>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Context),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Context>())).reg_mem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Context),
            "::",
            stringify!(reg_mem)
        )
    );
}
#[doc = " This type contains a Universally Unique Resource Identifier (UUID) type as"]
#[doc = " defined in RFC4122. These UUID values are used to identify Trusted"]
#[doc = " Applications."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TEEC_UUID {
    pub timeLow: u32,
    pub timeMid: u16,
    pub timeHiAndVersion: u16,
    pub clockSeqAndNode: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_TEEC_UUID() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_UUID>(),
        16usize,
        concat!("Size of: ", stringify!(TEEC_UUID))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_UUID>(),
        4usize,
        concat!("Alignment of ", stringify!(TEEC_UUID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_UUID>())).timeLow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_UUID),
            "::",
            stringify!(timeLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_UUID>())).timeMid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_UUID),
            "::",
            stringify!(timeMid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_UUID>())).timeHiAndVersion as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_UUID),
            "::",
            stringify!(timeHiAndVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_UUID>())).clockSeqAndNode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_UUID),
            "::",
            stringify!(clockSeqAndNode)
        )
    );
}
#[doc = " struct TEEC_SharedMemory - Memory to transfer data between a client"]
#[doc = " application and trusted code."]
#[doc = ""]
#[doc = " @param buffer      The memory buffer which is to be, or has been, shared"]
#[doc = "                    with the TEE."]
#[doc = " @param size        The size, in bytes, of the memory buffer."]
#[doc = " @param flags       Bit-vector which holds properties of buffer."]
#[doc = "                    The bit-vector can contain either or both of the"]
#[doc = "                    TEEC_MEM_INPUT and TEEC_MEM_OUTPUT flags."]
#[doc = ""]
#[doc = " A shared memory block is a region of memory allocated in the context of the"]
#[doc = " client application memory space that can be used to transfer data between"]
#[doc = " that client application and a trusted application. The user of this struct"]
#[doc = " is responsible to populate the buffer pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TEEC_SharedMemory {
    pub buffer: *mut ::core::ffi::c_void,
    pub size: size_t,
    pub flags: u32,
    pub id: ::std::os::raw::c_int,
    pub alloced_size: size_t,
    pub shadow_buffer: *mut ::core::ffi::c_void,
    pub registered_fd: ::std::os::raw::c_int,
    pub buffer_allocated: bool,
}
#[test]
fn bindgen_test_layout_TEEC_SharedMemory() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_SharedMemory>(),
        48usize,
        concat!("Size of: ", stringify!(TEEC_SharedMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_SharedMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(TEEC_SharedMemory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_SharedMemory>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_SharedMemory>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_SharedMemory>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_SharedMemory>())).id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_SharedMemory>())).alloced_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(alloced_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TEEC_SharedMemory>())).shadow_buffer as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(shadow_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TEEC_SharedMemory>())).registered_fd as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(registered_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TEEC_SharedMemory>())).buffer_allocated as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_SharedMemory),
            "::",
            stringify!(buffer_allocated)
        )
    );
}
impl Default for TEEC_SharedMemory {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct TEEC_TempMemoryReference - Temporary memory to transfer data between"]
#[doc = " a client application and trusted code, only used for the duration of the"]
#[doc = " operation."]
#[doc = ""]
#[doc = " @param buffer  The memory buffer which is to be, or has been shared with"]
#[doc = "                the TEE."]
#[doc = " @param size    The size, in bytes, of the memory buffer."]
#[doc = ""]
#[doc = " A memory buffer that is registered temporarily for the duration of the"]
#[doc = " operation to be called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TEEC_TempMemoryReference {
    pub buffer: *mut ::core::ffi::c_void,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_TEEC_TempMemoryReference() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_TempMemoryReference>(),
        16usize,
        concat!("Size of: ", stringify!(TEEC_TempMemoryReference))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_TempMemoryReference>(),
        8usize,
        concat!("Alignment of ", stringify!(TEEC_TempMemoryReference))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TEEC_TempMemoryReference>())).buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_TempMemoryReference),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_TempMemoryReference>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_TempMemoryReference),
            "::",
            stringify!(size)
        )
    );
}
impl Default for TEEC_TempMemoryReference {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct TEEC_RegisteredMemoryReference - use a pre-registered or"]
#[doc = " pre-allocated shared memory block of memory to transfer data between"]
#[doc = " a client application and trusted code."]
#[doc = ""]
#[doc = " @param parent  Points to a shared memory structure. The memory reference"]
#[doc = "                may utilize the whole shared memory or only a part of it."]
#[doc = "                Must not be NULL"]
#[doc = ""]
#[doc = " @param size    The size, in bytes, of the memory buffer."]
#[doc = ""]
#[doc = " @param offset  The offset, in bytes, of the referenced memory region from"]
#[doc = "                the start of the shared memory block."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TEEC_RegisteredMemoryReference {
    pub parent: *mut TEEC_SharedMemory,
    pub size: size_t,
    pub offset: size_t,
}
#[test]
fn bindgen_test_layout_TEEC_RegisteredMemoryReference() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_RegisteredMemoryReference>(),
        24usize,
        concat!("Size of: ", stringify!(TEEC_RegisteredMemoryReference))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_RegisteredMemoryReference>(),
        8usize,
        concat!("Alignment of ", stringify!(TEEC_RegisteredMemoryReference))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TEEC_RegisteredMemoryReference>())).parent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_RegisteredMemoryReference),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TEEC_RegisteredMemoryReference>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_RegisteredMemoryReference),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TEEC_RegisteredMemoryReference>())).offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_RegisteredMemoryReference),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for TEEC_RegisteredMemoryReference {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct TEEC_Value - Small raw data container"]
#[doc = ""]
#[doc = " Instead of allocating a shared memory buffer this structure can be used"]
#[doc = " to pass small raw data between a client application and trusted code."]
#[doc = ""]
#[doc = " @param a  The first integer value."]
#[doc = ""]
#[doc = " @param b  The second value."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TEEC_Value {
    pub a: u32,
    pub b: u32,
}
#[test]
fn bindgen_test_layout_TEEC_Value() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_Value>(),
        8usize,
        concat!("Size of: ", stringify!(TEEC_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_Value>(),
        4usize,
        concat!("Alignment of ", stringify!(TEEC_Value))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Value>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Value),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Value>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Value),
            "::",
            stringify!(b)
        )
    );
}
#[doc = " union TEEC_Parameter - Memory container to be used when passing data between"]
#[doc = "                        client application and trusted code."]
#[doc = ""]
#[doc = " Either the client uses a shared memory reference, parts of it or a small raw"]
#[doc = " data container."]
#[doc = ""]
#[doc = " @param tmpref  A temporary memory reference only valid for the duration"]
#[doc = "                of the operation."]
#[doc = ""]
#[doc = " @param memref  The entire shared memory or parts of it."]
#[doc = ""]
#[doc = " @param value   The small raw data container to use"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union TEEC_Parameter {
    pub tmpref: TEEC_TempMemoryReference,
    pub memref: TEEC_RegisteredMemoryReference,
    pub value: TEEC_Value,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_TEEC_Parameter() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_Parameter>(),
        24usize,
        concat!("Size of: ", stringify!(TEEC_Parameter))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_Parameter>(),
        8usize,
        concat!("Alignment of ", stringify!(TEEC_Parameter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Parameter>())).tmpref as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Parameter),
            "::",
            stringify!(tmpref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Parameter>())).memref as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Parameter),
            "::",
            stringify!(memref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Parameter>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Parameter),
            "::",
            stringify!(value)
        )
    );
}
impl Default for TEEC_Parameter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct TEEC_Session - Represents a connection between a client application"]
#[doc = " and a trusted application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TEEC_Session {
    pub ctx: *mut TEEC_Context,
    pub session_id: u32,
}
#[test]
fn bindgen_test_layout_TEEC_Session() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_Session>(),
        16usize,
        concat!("Size of: ", stringify!(TEEC_Session))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_Session>(),
        8usize,
        concat!("Alignment of ", stringify!(TEEC_Session))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Session>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Session),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Session>())).session_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Session),
            "::",
            stringify!(session_id)
        )
    );
}
impl Default for TEEC_Session {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " struct TEEC_Operation - Holds information and memory references used in"]
#[doc = " TEEC_InvokeCommand()."]
#[doc = ""]
#[doc = " @param   started     Client must initialize to zero if it needs to cancel"]
#[doc = "                      an operation about to be performed."]
#[doc = " @param   paramTypes  Type of data passed. Use TEEC_PARAMS_TYPE macro to"]
#[doc = "                      create the correct flags."]
#[doc = "                      0 means TEEC_NONE is passed for all params."]
#[doc = " @param   params      Array of parameters of type TEEC_Parameter."]
#[doc = " @param   session     Internal pointer to the last session used by"]
#[doc = "                      TEEC_InvokeCommand with this operation."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TEEC_Operation {
    pub started: u32,
    pub paramTypes: u32,
    pub params: [TEEC_Parameter; 4usize],
    pub session: *mut TEEC_Session,
}
#[test]
fn bindgen_test_layout_TEEC_Operation() {
    assert_eq!(
        ::core::mem::size_of::<TEEC_Operation>(),
        112usize,
        concat!("Size of: ", stringify!(TEEC_Operation))
    );
    assert_eq!(
        ::core::mem::align_of::<TEEC_Operation>(),
        8usize,
        concat!("Alignment of ", stringify!(TEEC_Operation))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Operation>())).started as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Operation),
            "::",
            stringify!(started)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Operation>())).paramTypes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Operation),
            "::",
            stringify!(paramTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Operation>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Operation),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TEEC_Operation>())).session as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TEEC_Operation),
            "::",
            stringify!(session)
        )
    );
}
impl Default for TEEC_Operation {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " TEEC_InitializeContext() - Initializes a context holding connection"]
    #[doc = " information on the specific TEE, designated by the name string."]
    #[doc = ""]
    #[doc = " @param name    A zero-terminated string identifying the TEE to connect to."]
    #[doc = "                If name is set to NULL, the default TEE is connected to. NULL"]
    #[doc = "                is the only supported value in this version of the API"]
    #[doc = "                implementation."]
    #[doc = ""]
    #[doc = " @param context The context structure which is to be initialized."]
    #[doc = ""]
    #[doc = " @return TEEC_SUCCESS  The initialization was successful."]
    #[doc = " @return TEEC_Result   Something failed."]
    pub fn TEEC_InitializeContext(
        name: *const ::std::os::raw::c_char,
        context: *mut TEEC_Context,
    ) -> TEEC_Result;
}
extern "C" {
    #[doc = " TEEC_FinalizeContext() - Destroys a context holding connection information"]
    #[doc = " on the specific TEE."]
    #[doc = ""]
    #[doc = " This function destroys an initialized TEE context, closing the connection"]
    #[doc = " between the client application and the TEE. This function must only be"]
    #[doc = " called when all sessions related to this TEE context have been closed and"]
    #[doc = " all shared memory blocks have been released."]
    #[doc = ""]
    #[doc = " @param context       The context to be destroyed."]
    pub fn TEEC_FinalizeContext(context: *mut TEEC_Context);
}
extern "C" {
    #[doc = " TEEC_OpenSession() - Opens a new session with the specified trusted"]
    #[doc = "                      application."]
    #[doc = ""]
    #[doc = " @param context            The initialized TEE context structure in which"]
    #[doc = "                           scope to open the session."]
    #[doc = " @param session            The session to initialize."]
    #[doc = " @param destination        A structure identifying the trusted application"]
    #[doc = "                           with which to open a session."]
    #[doc = ""]
    #[doc = " @param connectionMethod   The connection method to use."]
    #[doc = " @param connectionData     Any data necessary to connect with the chosen"]
    #[doc = "                           connection method. Not supported, should be set to"]
    #[doc = "                           NULL."]
    #[doc = " @param operation          An operation structure to use in the session. May"]
    #[doc = "                           be set to NULL to signify no operation structure"]
    #[doc = "                           needed."]
    #[doc = ""]
    #[doc = " @param returnOrigin       A parameter which will hold the error origin if"]
    #[doc = "                           this function returns any value other than"]
    #[doc = "                           TEEC_SUCCESS."]
    #[doc = ""]
    #[doc = " @return TEEC_SUCCESS      OpenSession successfully opened a new session."]
    #[doc = " @return TEEC_Result       Something failed."]
    #[doc = ""]
    pub fn TEEC_OpenSession(
        context: *mut TEEC_Context,
        session: *mut TEEC_Session,
        destination: *const TEEC_UUID,
        connectionMethod: u32,
        connectionData: *const ::core::ffi::c_void,
        operation: *mut TEEC_Operation,
        returnOrigin: *mut u32,
    ) -> TEEC_Result;
}
extern "C" {
    #[doc = " TEEC_CloseSession() - Closes the session which has been opened with the"]
    #[doc = " specific trusted application."]
    #[doc = ""]
    #[doc = " @param session The opened session to close."]
    pub fn TEEC_CloseSession(session: *mut TEEC_Session);
}
extern "C" {
    #[doc = " TEEC_InvokeCommand() - Executes a command in the specified trusted"]
    #[doc = " application."]
    #[doc = ""]
    #[doc = " @param session        A handle to an open connection to the trusted"]
    #[doc = "                       application."]
    #[doc = " @param commandID      Identifier of the command in the trusted application"]
    #[doc = "                       to invoke."]
    #[doc = " @param operation      An operation structure to use in the invoke command."]
    #[doc = "                       May be set to NULL to signify no operation structure"]
    #[doc = "                       needed."]
    #[doc = " @param returnOrigin   A parameter which will hold the error origin if this"]
    #[doc = "                       function returns any value other than TEEC_SUCCESS."]
    #[doc = ""]
    #[doc = " @return TEEC_SUCCESS  OpenSession successfully opened a new session."]
    #[doc = " @return TEEC_Result   Something failed."]
    pub fn TEEC_InvokeCommand(
        session: *mut TEEC_Session,
        commandID: u32,
        operation: *mut TEEC_Operation,
        returnOrigin: *mut u32,
    ) -> TEEC_Result;
}
extern "C" {
    #[doc = " TEEC_RegisterSharedMemory() - Register a block of existing memory as a"]
    #[doc = " shared block within the scope of the specified context."]
    #[doc = ""]
    #[doc = " @param context    The initialized TEE context structure in which scope to"]
    #[doc = "                   open the session."]
    #[doc = " @param sharedMem  pointer to the shared memory structure to register."]
    #[doc = ""]
    #[doc = " @return TEEC_SUCCESS              The registration was successful."]
    #[doc = " @return TEEC_ERROR_OUT_OF_MEMORY  Memory exhaustion."]
    #[doc = " @return TEEC_Result               Something failed."]
    pub fn TEEC_RegisterSharedMemory(
        context: *mut TEEC_Context,
        sharedMem: *mut TEEC_SharedMemory,
    ) -> TEEC_Result;
}
extern "C" {
    #[doc = " TEEC_AllocateSharedMemory() - Allocate shared memory for TEE."]
    #[doc = ""]
    #[doc = " @param context     The initialized TEE context structure in which scope to"]
    #[doc = "                    open the session."]
    #[doc = " @param sharedMem   Pointer to the allocated shared memory."]
    #[doc = ""]
    #[doc = " @return TEEC_SUCCESS              The registration was successful."]
    #[doc = " @return TEEC_ERROR_OUT_OF_MEMORY  Memory exhaustion."]
    #[doc = " @return TEEC_Result               Something failed."]
    pub fn TEEC_AllocateSharedMemory(
        context: *mut TEEC_Context,
        sharedMem: *mut TEEC_SharedMemory,
    ) -> TEEC_Result;
}
extern "C" {
    #[doc = " TEEC_ReleaseSharedMemory() - Free or deregister the shared memory."]
    #[doc = ""]
    #[doc = " @param sharedMem  Pointer to the shared memory to be freed."]
    pub fn TEEC_ReleaseSharedMemory(sharedMemory: *mut TEEC_SharedMemory);
}
extern "C" {
    #[doc = " TEEC_RequestCancellation() - Request the cancellation of a pending open"]
    #[doc = "                              session or command invocation."]
    #[doc = ""]
    #[doc = " @param operation Pointer to an operation previously passed to open session"]
    #[doc = "                  or invoke."]
    pub fn TEEC_RequestCancellation(operation: *mut TEEC_Operation);
}
